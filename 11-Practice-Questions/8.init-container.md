You are deploying an application container that requires a configuration file located at:

`/app/config/settings.json`


The application cannot start unless this file already exists.

However:

The config file must be downloaded from a remote URL:
`https://example.com/config/settings.json`

The main container image does not contain curl or wget

You cannot modify the main image

Therefore, you add an init container that:

Downloads the config file using wget or curl

Places it into a shared emptyDir volume

Exits successfully

Only then the main container starts, using the file from the same shared volume

ðŸ”§ Why Init Container Is Required

Main container cannot fetch configs itself

Init containers allow you to prepare the environment before the app starts

Init container ensures the app has everything it needs before startup

Init containers always run sequentially, never in parallel

The main container starts only after all init containers complete successfully


```yaml
initContainers:
  - name: fetch-config
    image: busybox
    command: ["sh", "-c", "wget -O /config/settings.json https://example.com/config/settings.json"]
    volumeMounts:
      - name: config-volume
        mountPath: /config

containers:
  - name: app
    image: myapp:v1
    volumeMounts:
      - name: config-volume
        mountPath: /app/config

volumes:
  - name: config-volume
    emptyDir: {}
```

Q2. You are deploying an application that needs to write logs to:

`/var/app/logs`

However:

- The main container runs as a non-root user (e.g., UID 1000)

- The log directory must be created and writable by this user

- The main app container image does not include tools like chown or chmod

- You cannot modify the main image

Your solution:

âž¤ Use an init container that runs as root to:

- Create /var/logs inside a shared volume
- Set permissions to allow UID 1000 to write
- mkdir -p /var/logs && chmod 777 /var/logs


(or better: chown 1000:1000 /var/logs)

âž¤ The main container starts after permissions are correctly set. This is a classic Kubernetes pattern.

ðŸ§ª Required Pod Behavior

- Init container prepares the filesystem
- Main container uses the directory afterward
- Both share the same emptyDir volume
- Init container runs once and exits
- Main container starts only after it succeeds

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: log-writer
spec:
  initContainers:
    - name: setup-permissions
      image: busybox
      command: ["sh", "-c", "mkdir -p /work/logs && chown 1000:1000 /work/logs"]
      volumeMounts:
        - name: workdir
          mountPath: /work

  containers:
    - name: app
      image: myapp:latest
      volumeMounts:
        - name: workdir
          mountPath: /var/app
      securityContext:
        runAsUser: 1000

  volumes:
    - name: workdir
      emptyDir: {}


```